#include "cramore.h"
#include "bcf_filtered_reader.h"
#include "sam_filtered_reader.h"
#include "sc_drop_seq.h"
#include "louvain.h"

struct dropD {
  int32_t nsnps;
  double llk0;
  double llk1;
  double llk2;

  dropD() : nsnps(0), llk0(0), llk1(0), llk2(0) {}
  dropD(int32_t _nsnps, double _llk0, double _llk1, double _llk2) :
    nsnps(_nsnps), llk0(_llk0), llk1(_llk1), llk2(_llk2) {}

  void set(int32_t _nsnps, double _llk0, double _llk1, double _llk2) {
    nsnps = _nsnps;
    llk0 = _llk0;
    llk1 = _llk1;
    llk2 = _llk2;
  }
};

///////////////////////////////////////////////////////////////////
// Freemuxlet : Genotype-free deconvolution of scRNA-seq doublets
//////////////////////////////////////////////////////////////////
int32_t cmdCramFreemuxlet(int32_t argc, char** argv) {
  //std::string gtfFile;
  std::string outPrefix;
  std::string plpPrefix;
  int32_t capBQ = 40;
  int32_t minBQ = 13;
  //std::vector<double> gridAlpha;
  double doublet_prior = 0.5;
  std::string groupList;
  int32_t minTotalReads = 0;
  int32_t minUniqReads = 0;
  int32_t minCoveredSNPs = 0;
  int32_t nSamples = 0;
  double bfThres = 5.41;

  paramList pl;

  BEGIN_LONG_PARAMS(longParameters)
    LONG_PARAM_GROUP("Options for input pileup", NULL)
    LONG_STRING_PARAM("plp",&plpPrefix, "Prefix of input files generated by dsc-pileup")

    LONG_PARAM_GROUP("Output Options", NULL)
    LONG_STRING_PARAM("out",&outPrefix,"Output file prefix")
//    LONG_MULTI_DOUBLE_PARAM("alpha",&gridAlpha, "Grid of alpha to search for (default is 0, 0.5)")
    LONG_DOUBLE_PARAM("doublet-prior",&doublet_prior, "Prior of doublet")
    LONG_INT_PARAM("nsample",&nSamples,"Number of samples multiplexed together")
    LONG_DOUBLE_PARAM("bf-thres",&bfThres,"Bayes Factor Threshold used in the initial clustering")    
    
    LONG_PARAM_GROUP("Read filtering Options", NULL)
    LONG_INT_PARAM("cap-BQ", &capBQ, "Maximum base quality (higher BQ will be capped)")
    LONG_INT_PARAM("min-BQ", &minBQ, "Minimum base quality to consider (lower BQ will be skipped)")

    LONG_PARAM_GROUP("Cell/droplet filtering options", NULL)
    LONG_STRING_PARAM("group-list",&groupList, "List of tag readgroup/cell barcode to consider in this run. All other barcodes will be ignored. This is useful for parallelized run")    
    LONG_INT_PARAM("min-total", &minTotalReads, "Minimum number of total reads for a droplet/cell to be considered")
    LONG_INT_PARAM("min-uniq", &minUniqReads, "Minimum number of unique reads (determined by UMI/SNP pair) for a droplet/cell to be considered")
    LONG_INT_PARAM("min-snp", &minCoveredSNPs, "Minimum number of SNPs with coverage for a droplet/cell to be considered")
  END_LONG_PARAMS();

  pl.Add(new longParams("Available Options", longParameters));
  pl.Read(argc, argv);
  pl.Status();

  if ( plpPrefix.empty() || outPrefix.empty() || ( nSamples == 0 ) )
    error("Missing required option(s) : --plp, --out, --nsample");

  /*
  if ( gridAlpha.empty() ) {
    gridAlpha.push_back(0);    
    gridAlpha.push_back(0.5);    
  }
  */

  std::set<std::string> bcdSet;
  sc_dropseq_lib_t scl;
  //int32_t nAlpha = (int32_t)gridAlpha.size();

  // Read droplet information from the mux-pileup output
  notice("Reading barcode information from %s.cel.gz..", plpPrefix.c_str());
  tsv_reader tsv_bcdf( (plpPrefix + ".cel.gz").c_str() );
  while( tsv_bcdf.read_line() > 0 ) {
    scl.add_cell(tsv_bcdf.str_field_at(1));
  }

  // Read SNP information from the mux-pileup output  
  tsv_reader tsv_varf( (plpPrefix + ".var.gz").c_str() );

  std::map<std::string, int32_t> chr2rid;
  std::vector<std::string> chroms;
  while( tsv_varf.read_line() > 0 ) {
    const char* chr = tsv_varf.str_field_at(1);
    if ( chr2rid.find(chr) == chr2rid.end() ) {
      int32_t newrid = chr2rid.size();
      chr2rid[chr] = newrid;
      chroms.push_back(chr);
    }
    int32_t rid = chr2rid[chr];
    int32_t pos = tsv_varf.int_field_at(2);
    char    ref = tsv_varf.str_field_at(3)[0];
    char    alt = tsv_varf.str_field_at(4)[0];
    double  af  = tsv_varf.double_field_at(5);

    if ( scl.add_snp(rid, pos, ref, alt, af, NULL) + 1 != tsv_varf.nlines )
      error("Expected SNP nID = %d but observed %s", tsv_varf.nlines-1, scl.nsnps-1);
  }

  // Read pileup information
  char buf[255];
  notice("Reading pileup information from %s.plp.gz..", plpPrefix.c_str());
  tsv_reader tsv_plpf( (plpPrefix + ".plp.gz").c_str() );
  int32_t numi = 0;
  while( tsv_plpf.read_line() > 0 ) {
    const char* pa = tsv_plpf.str_field_at(2);
    const char* pq = tsv_plpf.str_field_at(3);
    int32_t l = (int32_t)strlen(pq);
    
    if ( (int32_t)strlen(pq) != l )
      error("Length are different between %s and %s", pa, pq);
    
    for(int32_t i=0; i < l; ++i) {
      sprintf(buf, "%x", numi++);
      ++scl.cell_totl_reads[tsv_plpf.int_field_at(0)];    	
      scl.add_read( tsv_plpf.int_field_at(1), tsv_plpf.int_field_at(0), buf, (char)(pa[i]-(char)'0'), (char)(pq[i]-(char)33) ); 
    }
  }

  notice("Finished reading pileup information from %s.plp.gz..", plpPrefix.c_str());  

  struct sc_drop_comp_t {
    sc_dropseq_lib_t* pscl;
    sc_drop_comp_t(sc_dropseq_lib_t* p) : pscl(p) {}
    bool operator()(const int32_t& lhs, const int32_t& rhs) const {
      double cmp = pscl->cell_scores[lhs] - pscl->cell_scores[rhs];
      if ( cmp != 0 ) return cmp > 0;
      else return lhs > rhs;
    }
  };

  // sort cells based on the number of SNP-overlapping unique reads.

  // First, calculate the heterozygosity of each droplet to determine which droplet is
  // likely potentially doublets
  htsFile* wmix = hts_open((outPrefix+".lmix").c_str(),"w");
  hprintf(wmix, "INT_ID\tBARCODE\tNSNPs\tNREADs\tDBL.LLK\tSNG.LLK\tLOG.BF\tBFpSNP\n");

  std::vector< std::map<int32_t,snp_droplet_pileup> > cell_snp_plps(scl.nbcs);
    
  for(int32_t i=0; i < scl.nbcs; ++i) {
    int32_t si = i; // drops_srted[i];
    if (i % 1000 == 0 )
      notice("Processing doublet likelihoods for %d droplets..", i+1);

    int32_t nSNPs = 0;
    int32_t nReads = 0;
    
    // likelihood calculation across the overlapping SNPs
    std::map<int32_t,sc_snp_droplet_t* >::iterator it = scl.cell_umis[si].begin();

    double llk0 = 0, llk2 = 0; // LLK of IBD0, IBD1, IBD2     
    
    while( it != scl.cell_umis[si].end() ) {
      //double gls[9] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
      double af = scl.snps[it->first].af;

      // calculate genotype likelihoods
      //calculate_snp_droplet_doublet_GL(it->second, gls, 0.5);
      calculate_snp_droplet_pileup(it->second, cell_snp_plps[i][it->first], 0.5);
      double* gls = cell_snp_plps[i][it->first].gls;

      double lk0 = 0, lk2 = 0;
      double gps[3];
      gps[0] = (1.0-af) * (1.0-af);
      gps[1] = 2.0 * af * (1.0-af);
      gps[2] = af * af;
	
      for(int32_t gi=0; gi < 3; ++gi) {
	lk2 += ( gls[gi*3 + gi] * gps[gi] );
	for(int32_t gj=0; gj < 3; ++gj) {
	  lk0 += ( gls[gi*3 + gj] * gps[gi] * gps[gj] );
	}
      }
      nReads += (int32_t)it->second->size();
      ++nSNPs;
      
      ++it;

      llk0 += log(lk0);
      llk2 += log(lk2);
    }

    scl.cell_scores[si] = llk2 - llk0;  // score of being singlet

    hprintf(wmix,"%d\t%s\t%d\t%d\t%.2lf\t%.2lf\t%.2lf\t%.4lf\n", si, scl.bcs[si].c_str(), nSNPs, nReads, llk0, llk2, llk0-llk2, (llk0-llk2)/nSNPs);
  }
  hts_close(wmix);

  // sort droplets by singlet scores
  std::vector<int32_t> drops_srted(scl.nbcs);
  for(int32_t i=0; i < scl.nbcs; ++i) {
    drops_srted[i] = i;
  }  
  sc_drop_comp_t sdc(&scl);
  std::sort( drops_srted.begin(), drops_srted.end(), sdc );  

  // store pairwise distances
  std::vector< std::vector<dropD> > dropDs;

  htsFile* wf = hts_open((outPrefix+".ldist.gz").c_str(),"wz");
  //htsFile* wm = hts_open((outPrefix+".dist_mat.gz").c_str(),"wz");  
  hprintf(wf, "ID1\tID2\tNSNP\tREAD1\tREAD2\tREADMIN\tLLK0\tLLK1\tLLK2\tLDIFF\tDIFF.SNP\n");
  
  //hprintf(wm,"%d\n", scl.nbcs);
  //for(int32_t i=0; i < scl.nbcs; ++i) {
  //  if ( i+1 == scl.nbcs ) hprintf(wm,"%d\n",drops_srted[i]);
  //  else hprintf(wm,"%d\t",drops_srted[i]);
  //}

  std::vector<double> votes(nSamples);
  std::vector<int32_t> clusts(scl.nbcs,-1);
  std::vector<int32_t> ccounts(nSamples,0);  
  for(int32_t i=0; i < scl.nbcs; ++i) {
    int32_t si = drops_srted[i];
    //bool clique = true;
    //int32_t clust = -1;

    dropDs.resize(i+1);

    if (i % 50 == 0 ) {
      std::string buf;
      for(int32_t j=0; j < nSamples; ++j) 
	catprintf(buf, " %d",ccounts[j]);
      notice("Processing %d droplets.. cluster counts:%s", i+1, buf.c_str());
    }

    for(int32_t j=0; j < nSamples; ++j) {
      votes[j] = rand()/(RAND_MAX+1.)/1000.;
    }

    for(int32_t j=0; j < i; ++j) {
      int32_t sj = drops_srted[j];

      // likelihood calculation across the overlapping SNPs
      std::map<int32_t,sc_snp_droplet_t* >::iterator iti = scl.cell_umis[si].begin();
      std::map<int32_t,sc_snp_droplet_t* >::iterator itj = scl.cell_umis[sj].begin();

      int32_t nInformativeSNPs = 0;
      int32_t nInformativeRead1 = 0;
      int32_t nInformativeRead2 = 0;
      int32_t nInformativeReadMin = 0;       
      double llk0 = 0, llk1 = 0, llk2 = 0; // LLK of IBD0, IBD1, IBD2 
      while( ( iti != scl.cell_umis[si].end() ) && ( itj != scl.cell_umis[sj].end() ) ) {
	if ( iti->first == itj->first ) {  // overlapping SNPs exist
	  // calculate Pr(D|g) 
	  //double glis[3] = {1.0, 1.0, 1.0};
	  //double gljs[3] = {1.0, 1.0, 1.0};
	  double af = scl.snps[iti->first].af;
	  double lk0 = 0, lk1 = 0, lk2 = 0;
	  double gps[3];
	  double tps[9] = {0,0,0,0,0,0,0,0,0};
	  gps[0] = (1.0-af) * (1.0-af);
	  gps[1] = 2.0 * af * (1.0-af);
	  gps[2] = af * af;
	  tps[0] = (1.0-af) * (1.0-af) * (1.0-af);
	  tps[1] = tps[3] = (1.0-af) * (1.0-af) * af;
	  tps[5] = tps[7] = (1.0-af) * af * af;
	  tps[4] = tps[1] + tps[5];
	  tps[8] = af * af * af;

	  // calculate genotype likelihoods
	  //calculate_snp_droplet_GL(iti->second, glis);
	  //calculate_snp_droplet_GL(itj->second, gljs);
	  double* glis = cell_snp_plps[si][iti->first].gls;
	  double* gljs = cell_snp_plps[sj][itj->first].gls;	  

	  for(int32_t gi=0; gi < 3; ++gi) {
	    lk2 += ( glis[gi*3+gi] * gljs[gi*3+gi] * gps[gi] );
	    for(int32_t gj=0; gj < 3; ++gj) {
	      lk0 += ( glis[gi*3+gi] * gljs[gj*3+gj] * gps[gi] * gps[gj] );
	      lk1 += ( glis[gi*3+gi] * gljs[gj*3+gj] * tps[gi*3+gj] );
	    }
	  }

	  llk2 += log(lk2);
	  llk1 += log(lk1);	  
	  llk0 += log(lk0);

	  ++nInformativeSNPs;
	  ++iti;
	  ++itj;
	  nInformativeRead1 += (int32_t)scl.cell_umis[si].size();
	  nInformativeRead2 += (int32_t)scl.cell_umis[sj].size();
	  nInformativeReadMin += (int32_t)(scl.cell_umis[si].size() > scl.cell_umis[sj].size() ? scl.cell_umis[sj].size() : scl.cell_umis[si].size() );
	}
	else if ( iti->first < itj->first ) ++iti;
	else ++itj;
      }

      
      dropDs[i].push_back( dropD(nInformativeSNPs, llk0, llk1, llk2) );

      hprintf(wf, "%d\t%d\t%d\t%d\t%d\t%d\t%.2lf\t%.2lf\t%.2lf\t%.2lf\t%.4lf\n", si, sj, nInformativeSNPs, nInformativeRead1, nInformativeRead2, nInformativeReadMin, llk0, llk1, llk2, llk2-llk0, (llk2-llk0)/(nInformativeSNPs+1.0));

      if ( clusts[sj] < 0 )
	error("i = %d, si = %d, j = %d, sj = %d, clust[%d] = %d", i, si, j, sj, sj, clusts[sj]);

      if ( llk0-llk2 > bfThres ) {
	votes[clusts[sj]] -= 1.0;
      }
      else if ( llk2-llk0 > bfThres ) {
	votes[clusts[sj]] += 1.0;	
      }

      //if ( llk2 > llk0 + 2 ) {
      //lv.add_edge(si, sj, 1.0);
      //}

      //if ( j + 1 == i ) hprintf(wm, "%.5lf\n", (llk2-llk0)/(nInformativeSNPs+1.0));
      //else hprintf(wm, "%.5lf\t", (llk2-llk0)/(nInformativeSNPs+1.0));
    }

    int32_t elected = 0;
    double maxvote = votes[0];
    for(int32_t j=1; j < nSamples; ++j) {
      if ( maxvote < votes[j] ) {
	elected = j;
	maxvote = votes[j];
      }
    }
    clusts[si] = elected;
    ++ccounts[elected];
    //notice("clusts[%d] = %d", si, elected);
  }

  hts_close(wf);
  //hts_close(wm);

  notice("Finished calculating pairwise distance between the droplets..");

  for(int32_t iter=0; iter < 10; ++iter) {
    int32_t changed = 0;

    std::fill(ccounts.begin(), ccounts.end(), 0);

    for(int32_t i=0; i < scl.nbcs; ++i) {
      int32_t si = drops_srted[i];

      for(int32_t j=0; j < nSamples; ++j) {
	votes[j] = rand()/(RAND_MAX+1.)/1000.;
      }
      
      for(int32_t j=0; j < scl.nbcs; ++j) {
	int32_t sj = drops_srted[j];	
	if ( i != j ) {
	  double bf = ( j < i ) ? ( dropDs[i][j].llk2 - dropDs[i][j].llk0 ) : ( dropDs[j][i].llk2 - dropDs[j][i].llk0 );
	  if ( bf > bfThres ) { ++votes[clusts[sj]]; }
	  else if ( bf < 0-bfThres ) { --votes[clusts[sj]]; }
	}
      }

      int32_t elected = 0;
      double maxvote = votes[0];
      for(int32_t j=1; j < nSamples; ++j) {
	if ( maxvote < votes[j] ) {
	  elected = j;
	  maxvote = votes[j];
	}
      }
      if ( clusts[si] != elected ) ++changed;
      clusts[si] = elected;
      ++ccounts[elected];
    }

    std::string buf;
    for(int32_t j=0; j < nSamples; ++j) 
      catprintf(buf, " %d",ccounts[j]);
    notice("Iteration %d, # changed = %d, cluster counts:%s",iter, changed, buf.c_str());
  }

  htsFile* wc0 = hts_open((outPrefix+".clust0.samples.gz").c_str(),"wz");
  hprintf(wc0, "INT_ID\tBARCODE\tCLUST0\n");
  //std::vector< std::vector<int32_t> > iclusts(nSamples);
  for(int32_t i=0; i < scl.nbcs; ++i) {
    hprintf(wc0, "%d\t%s\t%d\n", i, scl.bcs[i].c_str(), clusts[i]);
    //iclusts[clusts[i]].push_back(i);
  }
  hts_close(wc0);

  std::vector< std::map<int32_t,snp_droplet_pileup> > clustPileup(nSamples);

  std::vector<bool> snps_observed(scl.nsnps,false);
  for(int32_t i=0; i < scl.nbcs; ++i) {
    std::map<int32_t,snp_droplet_pileup>::const_iterator it = cell_snp_plps[i].begin();
    while(it != cell_snp_plps[i].end()) {
      clustPileup[clusts[i]][it->first].merge(it->second);
      snps_observed[it->first] = true;
      ++it;
    }
  }
  
  htsFile* vc0 = hts_open((outPrefix+".clust0.vcf.gz").c_str(),"wz");
  hprintf(vc0,"##CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT");
  for(int32_t i=0; i < nSamples; ++i) hprintf(vc0, "\tCLUST%d", i);
  hprintf(vc0, "\n");
  for(int32_t v=0; v < scl.nsnps; ++v) {
    if ( !snps_observed[v] ) continue;
    sc_snp_t& s = scl.snps[v];
    hprintf(vc0,"%s\t%d\t.\t%c\t%c\t.\tPASS\tAF=%.5lf\tDP:AD:PL",chroms[s.rid].c_str(),s.pos,s.ref,s.alt,s.af);
    for(int32_t i=0; i < nSamples; ++i) {
      snp_droplet_pileup& sdp = clustPileup[i][v];
      double maxGL = sdp.gls[0];
      if ( maxGL < sdp.gls[4] ) maxGL = sdp.gls[4];
      if ( maxGL < sdp.gls[8] ) maxGL = sdp.gls[8];
      int32_t pls[3];
      pls[0] = (int)(-10.0*log10(sdp.gls[0]/maxGL));
      pls[1] = (int)(-10.0*log10(sdp.gls[4]/maxGL));
      pls[2] = (int)(-10.0*log10(sdp.gls[8]/maxGL));      
      hprintf(vc0,"\t%d:%d,%d:%d,%d,%d",sdp.nreads,sdp.nref,sdp.nalt,pls[0],pls[1],pls[2]);
    }
    hprintf(vc0,"\n");
  }
  hts_close(vc0);


  std::vector<int32_t> jClusts(scl.nbcs,-1);
  std::vector<int32_t> kClusts(scl.nbcs,-1);
      
  // calculate probabilities of singlets/doublets
  for(int32_t iter=0; iter < 10; ++iter) {
    notice("Inferring doublets and refining clusters.., iter = %d", iter+1);
    
    double gp1s[3], gp2s[3], sum1, sum2;
    int32_t npairs = nSamples*(nSamples+1)/2;
    double log_single_prior = log((1.0-doublet_prior)/nSamples);
    double log_double_prior = log(doublet_prior/nSamples/(nSamples-1)*2.0);

    for(int32_t i=0; i < scl.nbcs; ++i) {
      std::vector<double> llks(npairs, 0);
      std::map<int32_t,snp_droplet_pileup>::iterator it;
      for(it = cell_snp_plps[i].begin(); it != cell_snp_plps[i].end(); ++it) {
	double af = scl.snps[it->first].af;
	std::vector<double> lks(npairs, 0);
	double lk;
	for(int32_t j=0; j < nSamples; ++j) {
	  snp_droplet_pileup& sdp1 = clustPileup[j][it->first];
	  gp1s[0] = (1.0-af)*(1.0-af)*sdp1.gls[0];
	  gp1s[1] = 2*af*(1.0-af)*sdp1.gls[4];
	  gp1s[2] = af*af*sdp1.gls[8];
	  sum1 = gp1s[0]+gp1s[1]+gp1s[2];
	  gp1s[0] /= sum1;
	  gp1s[1] /= sum1;
	  gp1s[2] /= sum1;	
	  for(int32_t k=0; k < j; ++k) {
	    snp_droplet_pileup& sdp2 = clustPileup[k][it->first];	  
	    // Pr(D|g1,g2)Pr(g1|C1)Pr(g2|C2)Pr(C1)Pr(C2)
	    gp2s[0] = (1.0-af)*(1.0-af)*sdp2.gls[0];
	    gp2s[1] = 2*af*(1.0-af)*sdp2.gls[4];
	    gp2s[2] = af*af*sdp2.gls[8];
	    sum2 = gp2s[0]+gp2s[1]+gp2s[2];
	    gp2s[0] /= sum2;
	    gp2s[1] /= sum2;
	    gp2s[2] /= sum2;		  
	    
	    lk = 0;
	    for(int32_t g1=0; g1 < 3; ++g1) {
	      for(int32_t g2=0; g2 < 3; ++g2) {
		lk += ( it->second.gls[g1*3+g2] * gp1s[g1] * gp2s[g2] );
	      }
	    }
	    lks[j*(j+1)/2+k] = lk;
	  }
	  lk = 0;
	  for(int32_t g1=0; g1 < 3; ++g1) {
	    lk += ( it->second.gls[g1*3+g1] * gp1s[g1] );
	  }
	  lks[j*(j+1)/2+j] = lk;
	}
	for(int32_t i=0; i < npairs; ++i)
	  llks[i] += log(lks[i]);
      }

      int32_t jBest = -1, kBest = -1;
      double bestLLK = -1e300;
      for(int32_t j=0; j < nSamples; ++j) {
	for(int32_t k=0; k < j; ++k) {
	  if ( llks[j*(j+1)/2+k] + log_double_prior > bestLLK ) {
	    jBest = j; kBest = k;
	    bestLLK = llks[j*(j+1)/2+k] + log_double_prior;
	  }
	}
	if ( llks[j*(j+1)/2+j] + log_single_prior > bestLLK ) {
	  jBest = j; kBest = j;
	  bestLLK = llks[j*(j+1)/2+j] + log_single_prior;	  
	}
      }

      jClusts[i] = jBest;
      kClusts[i] = kBest;
    }

    clustPileup.clear();
    for(int32_t i=0; i < scl.nbcs; ++i) {
      std::map<int32_t,snp_droplet_pileup>::const_iterator it = cell_snp_plps[i].begin();
      while(it != cell_snp_plps[i].end()) {
	if ( jClusts[i] == kClusts[i] ) 
	  clustPileup[jClusts[i]][it->first].merge(it->second);
	++it;
      }
    }    
  }


  htsFile* vc1 = hts_open((outPrefix+".clust1.vcf.gz").c_str(),"wz");
  hprintf(vc1,"##CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT");
  for(int32_t i=0; i < nSamples; ++i) hprintf(vc1, "\tCLUST%d", i);
  hprintf(vc1, "\n");
  for(int32_t v=0; v < scl.nsnps; ++v) {
    if ( !snps_observed[v] ) continue;
    sc_snp_t& s = scl.snps[v];
    hprintf(vc1,"%s\t%d\t.\t%c\t%c\t.\tPASS\tAF=%.5lf\tDP:AD:PL",chroms[s.rid].c_str(),s.pos,s.ref,s.alt,s.af);
    for(int32_t i=0; i < nSamples; ++i) {
      snp_droplet_pileup& sdp = clustPileup[i][v];
      double maxGL = sdp.gls[0];
      if ( maxGL < sdp.gls[4] ) maxGL = sdp.gls[4];
      if ( maxGL < sdp.gls[8] ) maxGL = sdp.gls[8];
      int32_t pls[3];
      pls[0] = (int)(-10.0*log10(sdp.gls[0]/maxGL));
      pls[1] = (int)(-10.0*log10(sdp.gls[4]/maxGL));
      pls[2] = (int)(-10.0*log10(sdp.gls[8]/maxGL));      
      hprintf(vc1,"\t%d:%d,%d:%d,%d,%d",sdp.nreads,sdp.nref,sdp.nalt,pls[0],pls[1],pls[2]);
    }
    hprintf(vc1,"\n");
  }
  hts_close(vc1);

  htsFile* wc1 = hts_open((outPrefix+".clust1.samples.gz").c_str(),"wz");
  hprintf(wc1, "INT_ID\tBARCODE\tCLUST0\tCLUST1\tCLUST2\tTYPE\n");
  for(int32_t i=0; i < scl.nbcs; ++i) {
    hprintf(wc1, "%d\t%s\t%d\t%d\t%d\t%s\n", i, scl.bcs[i].c_str(), clusts[i], jClusts[i], kClusts[i], jClusts[i] == kClusts[i] ? "SNG" : "DBL");
  }
  hts_close(wc1);  

  //notice("Finding clusters...");

  /*
  lv.make_cluster_pass(true);
  lv.print_summary();

  // print out cluster assignments
  std::vector<int32_t> iclust(scl.nbcs, -1);
  std::vector<lnode*>& nodes = lv.root->children;
  for(int32_t i=0; i < (int32_t)nodes.size(); ++i) {
    for(int32_t j=0; j < (int32_t)nodes[i]->children.size(); ++j) {
      iclust[nodes[i]->children[j]->id] = i;
    }
  }
  for(int32_t i=0; i < (int32_t)iclust.size(); ++i) {
    printf("%s\t%d\n", scl.bcs[i].c_str(), iclust[i]);
  }
  */  

  return 0;
}
